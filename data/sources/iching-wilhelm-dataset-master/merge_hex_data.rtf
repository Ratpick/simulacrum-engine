{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 // merge_hex_data.ts\
type MinimalHex = \{\
  id: number;                  // 1..64\
  title: string;               // "11 \'b7 Tai (Peace)"  <-- must exactly match Notion page titles\
\};\
\
type MITHex = \{\
  number: number;              // 1..64\
  chinese?: string;            // \uc0\u21350 \u21517 \
  pinyin?: string;             // e.g., "T\'e0i"\
  upper_trigram: string;       // "Kun", "Qian", etc.\
  lower_trigram: string;\
  binary_btt: string;          // "111000" bottom->top (1=yang)\
  // NOTE: ignore long translation strings here\
\};\
\
type PublicHex = \{\
  id: number;\
  title: string;               // exact Notion title key\
  chinese?: string;\
  pinyin?: string;\
  upper_trigram: string;\
  lower_trigram: string;\
  binary_btt: string;\
  // space for YOUR summaries only:\
  judgment_summary?: string;\
  image_summary?: string;\
\};\
\
export function mergeHex(minimal: MinimalHex[], mit: MITHex[]): PublicHex[] \{\
  const byId = new Map(mit.map(h => [h.number, h]));\
  return minimal.map(min => \{\
    const src = byId.get(min.id);\
    if (!src) throw new Error(`No MIT record for hex $\{min.id\}`);\
    return \{\
      id: min.id,\
      title: min.title,                       // exact key for Notion Relations\
      chinese: src.chinese,\
      pinyin: src.pinyin,\
      upper_trigram: src.upper_trigram,\
      lower_trigram: src.lower_trigram,\
      binary_btt: src.binary_btt,\
      judgment_summary: "",                   // fill with YOUR paraphrase\
      image_summary: "",                      // fill with YOUR paraphrase\
    \};\
  \});\
\}\
\
// Utility: compute a moving mask and list between two hexes\
export function movingMask(fromBits: string, toBits: string) \{\
  if (fromBits.length !== 6 || toBits.length !== 6) throw new Error("Need 6-bit strings");\
  const mask = [...fromBits].map((b, i) => (b === toBits[i] ? "0" : "1")).join("");\
  const lines = [...mask]\
    .map((b, i) => (b === "1" ? i + 1 : 0))  // lines numbered bottom(1)\'85top(6)\
    .filter(n => n > 0);\
  return \{ mask, lines \};                     // e.g., \{ mask:"111001", lines:[1,2,3,6] \}\
\}}